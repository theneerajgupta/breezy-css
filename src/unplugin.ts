import { createUnplugin } from 'unplugin';
import { parse } from '@babel/parser';
import traverseDefault from '@babel/traverse';
import generateDefault from '@babel/generator';
import * as t from '@babel/types';
import * as fs from 'fs';
import * as path from 'path';

const traverse = traverseDefault.default || traverseDefault;
const generate = generateDefault.default || generateDefault;

const discoveredClasses = new Set<string>();
let writeTimeout: NodeJS.Timeout | null = null;

export default createUnplugin(() => ({
  name: 'breezy-css',
  enforce: 'pre',

  buildStart() {
    discoveredClasses.clear();
  },

  transform(code: string, id: string) {
    // Handle CSS files - inject @source for Tailwind
    if (/\.css$/.test(id)) {
      return transformCSS(code);
    }

    // Handle JSX/TSX files
    if (!/\.[jt]sx$/.test(id)) {
      return null;
    }

    if (!/\s(sm|md|lg|xl|xxl)=/.test(code)) {
      return null;
    }

    try {
      const result = transformWithAST(code, id);
      
      if (result && discoveredClasses.size > 0) {
        scheduleWriteSafelist();
      }
      
      return result;
    } catch (error) {
      console.error(`[breezy-css] Transform error in ${id}:`, error);
      return null;
    }
  },

  buildEnd() {
    if (discoveredClasses.size > 0) {
      writeSafelistFile(discoveredClasses);
    }
  },
}));

/**
 * Transform CSS to inject @source directive for Tailwind
 */
function transformCSS(code: string): { code: string } | null {
  // Check if this CSS file imports Tailwind
  if (!/@import\s+["']tailwindcss["']/.test(code)) {
    return null;
  }

  // Check if @source already exists
  if (/@source\s+["'][^"']*\.breezy/.test(code)) {
    return null;
  }

  // Inject @source directive after @import "tailwindcss"
  const transformedCode = code.replace(
    /(@import\s+["']tailwindcss["'];?)/,
    '$1\n@source "../.breezy";'
  );

  if (transformedCode !== code) {
    return { code: transformedCode };
  }

  return null;
}

function scheduleWriteSafelist(): void {
  if (writeTimeout) {
    clearTimeout(writeTimeout);
  }
  
  writeTimeout = setTimeout(() => {
    writeSafelistFile(discoveredClasses);
    writeTimeout = null;
  }, 100);
}

function transformWithAST(code: string, filename: string): { code: string; map?: any } | null {
  const ast = parse(code, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript'],
    sourceFilename: filename,
  });

  let hasTransformations = false;

  traverse(ast, {
    JSXOpeningElement(path) {
      const attributes = path.node.attributes;
      const responsiveProps: Record<string, string> = {};
      let classNameAttr: t.JSXAttribute | null = null;
      const otherAttributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [];

      for (const attr of attributes) {
        if (t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name)) {
          const attrName = attr.name.name;

          if (['sm', 'md', 'lg', 'xl', 'xxl'].includes(attrName)) {
            const value = getAttributeValue(attr);
            if (value) {
              responsiveProps[attrName] = value;
              hasTransformations = true;
            }
          } else if (attrName === 'className') {
            classNameAttr = attr;
          } else {
            otherAttributes.push(attr);
          }
        } else {
          otherAttributes.push(attr);
        }
      }

      if (Object.keys(responsiveProps).length > 0) {
        const transformedClassName = buildClassName(
          classNameAttr ? getAttributeValue(classNameAttr) : '',
          responsiveProps
        );

        trackDiscoveredClasses(responsiveProps);

        const newClassNameAttr = t.jsxAttribute(
          t.jsxIdentifier('className'),
          t.stringLiteral(transformedClassName)
        );

        path.node.attributes = [...otherAttributes, newClassNameAttr];
      }
    },
  });

  if (!hasTransformations) {
    return null;
  }

  const result = generate(ast, {
    retainLines: true,
    sourceMaps: true,
    sourceFileName: filename,
  }, code);

  return {
    code: result.code,
    map: result.map,
  };
}

function trackDiscoveredClasses(responsiveProps: Record<string, string>): void {
  const breakpointMap: Record<string, string> = {
    sm: 'sm:',
    md: 'md:',
    lg: 'lg:',
    xl: 'xl:',
    xxl: '2xl:',
  };

  for (const [breakpoint, classString] of Object.entries(responsiveProps)) {
    const prefix = breakpointMap[breakpoint];
    classString.split(' ').forEach(cls => {
      if (cls.trim()) {
        discoveredClasses.add(`${prefix}${cls.trim()}`);
      }
    });
  }
}

function writeSafelistFile(classes: Set<string>): void {
  const breezyDir = '.breezy';
  const safelistPath = path.join(breezyDir, 'safelist.tsx');

  try {
    if (!fs.existsSync(breezyDir)) {
      fs.mkdirSync(breezyDir, { recursive: true });
    }

    const classArray = Array.from(classes).sort();
    const content = `/**
 * AUTO-GENERATED by breezy-css
 * DO NOT EDIT - This file is regenerated on every build
 */

export const BREEZY_SAFELIST = [
${classArray.map(cls => `  "${cls}",`).join('\n')}
] as const;

export const _BreezyTailwindSafelist = () => (
  <div className="${classArray.join(' ')}" />
);
`;

    fs.writeFileSync(safelistPath, content, 'utf-8');
  } catch (error) {
    console.error('[breezy-css] Error writing safelist:', error);
  }
}

function getAttributeValue(attr: t.JSXAttribute): string | null {
  if (!attr.value) return null;

  if (t.isStringLiteral(attr.value)) {
    return attr.value.value;
  }

  if (t.isJSXExpressionContainer(attr.value)) {
    const expr = attr.value.expression;
    if (t.isStringLiteral(expr)) {
      return expr.value;
    }
    if (t.isTemplateLiteral(expr) && expr.quasis.length === 1) {
      return expr.quasis[0].value.raw;
    }
  }

  return null;
}

function buildClassName(baseClassName: string, responsiveProps: Record<string, string>): string {
  const classes: string[] = [];

  if (baseClassName) {
    classes.push(baseClassName);
  }

  const breakpointMap: Record<string, string> = {
    sm: 'sm:',
    md: 'md:',
    lg: 'lg:',
    xl: 'xl:',
    xxl: '2xl:',
  };

  for (const [breakpoint, classString] of Object.entries(responsiveProps)) {
    const prefix = breakpointMap[breakpoint];
    const prefixedClasses = classString
      .split(' ')
      .filter(Boolean)
      .map(cls => `${prefix}${cls}`)
      .join(' ');

    if (prefixedClasses) {
      classes.push(prefixedClasses);
    }
  }

  return classes.join(' ');
}
